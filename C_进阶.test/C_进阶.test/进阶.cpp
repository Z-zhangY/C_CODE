#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<math.h>
#include<string.h>
#include<windows.h>
#include<assert.h>
// release 和 debug 区别
// release 版本会对代码做相应的优化
//
//int main()
//{
//	int i = 0;
//	int arr[10] = {1,2,3,4,5,6,7,8,9,10 };
//	printf("%p\n", arr);
//	printf("%p\n", &i);
//	for (i = 0; i <= 12; i++)
//	{
//		arr[i] = 0;
//		printf("hehe\n");
//	}
//	return 0;
//}
// debug 版本程序会越界访问到 i ，造成死循环
//int main()
//{
//	while (1)
//	{
//		printf("hehe\n");
//	}
//	return 0;
//}
//

//
// C语言进阶
// 
// 一.数据的储存
// 二.指针的进阶
// 三.字符串+内存函数的介绍
// 四.自定义类型详解（结构体+枚举+联合）
// 五.动态内存管理
// 六.文件操作
// 七.程序的编译（预处理操作）+	链接
//
//
// 一. 深度剖析数据在内存中的存储
// *数据类型详细介绍
//  整型 原反补
//  大小端字节序介绍及判断
//  浮点型在内存中的存储解析
// 
// 1.数据类型介绍
//  类型的意义
//		使用这个类型开辟内存空间的大小
//		如何看待内存空间的视角
// 
//  1.1 整型家族 
//		char  (字符的本质是 ASCII码值)
//			char 的标准取决于编译器
//			unsigned char
//			signed char
//		short 
//			unsigned short (int)
//			signed short (int)   -> short
//		int 
//			unsigned int
//			signed int  -> int  
//		long
//			unsinged long
//			signed long   ->  long 
//		long long
//			unsigned long long 
//			singed long long   -> long long
//  1.2 浮点型家族（表示小数）
//      float 的精度低，存储的数据范围小
//		double 的精度高，存储的数据范围大
//	1.3 构造类型 -> 自定义类型
//		数组类型    int arr1[10]  char arr2[10]
//		结构体类型  struct
//		枚举类型    enum
//		联合类型    union
//  1.5 指针类型
//		int *pi
//		char *pc
//		float *pf
//		void *pv
//  1.6 空类型
//      void 表示空类型（无类型）
//		通常用于函数的返回类型，函数的参数，指针类型
//
//
// 2.整型在内存中的存储
//    整数在内存中存放的是补码的二进制序列
//	  使用补码存储可以将数值域和符号域统一起来运算    
//	  整型数据范围定义头文件 <limits.h>
//  2.1 原码 反码 补码 
//  数据的表示形式
//	21
//  二进制  ->  0b10101    （原码 反码 补码）
//  八进制  ->  025
//  十进制  ->  21
//  十六进制  -> 0x15 
//
//int main()
//{
//	int a = 10;
//
//	int b = -20;
//
//
//	return 0;
//}
//  2.2 大小端介绍
//		以字节为顺序
//		低地址  -> 高地址
//		0x 11 22 33 44   大端字节序存储  （高位字节序的内容存放在低地址处……）
//		0x 44 33 22 11   小端字节序存储  （低位字节序的内容存放在高地址出……）
//      char int  short  float 等数据类型都按照字节序存储
//		char ch ='w';  只占一个字节，没有大小端
//		char ch ="abcede"; 超过一个字节，按照字节序存储
//
//      2015年百度工程师面试笔试题	
//		简述大小端字节序的概念，并写出一个代码验证当前编译器
//
//int main()
//{
//	int a = 1;
//	int* p = &a;
//	if (*(char*)&a == 1)
//	{
//		printf("小端\n");
//	}
//	else
//	{
//		printf("大端\n");
//	}
//	return 0;
//}
//
//int check_sys()
//{
//	int a = 1;
//	if (*(char*)&a == 1)
//		return 1; // 小端
//	else
//		return 0; // 大端
//}
//int main()
//{
//	int ret = check_sys();
//	if (ret == 1)
//		printf("小端\n");
//	else
//		printf("大端\n");
//	return 0;
//}
//
//  2.3 练习
//  2.3.1
// 输出什么
// 把整型放在 char 类型之中，会用到 截断和整型提升
// 有符号的 高位补 1； 无符号的 高位补 0；
//int main()
//{
//	char a = -1;                 // -1
//	signed char b = -1;          // -1
//	//
//	// 有符号的 char 取值范围 -128 -> 127
//	//
//	unsigned char c = -1;        // 255
//	//
//	// 无符号的 char 取值范围 0 -> 255
//	//
//	printf("%d %d %d\n", a, b, c);
//	return 0;
//}
//
// 2.3.2
//
// 截断之后进行整型提升，提升完之后直接打印
// 无符号数 补码 = 原码，不用算原码
//
//int main()
//{
//	char a = -128;   
//	printf("%u", a);
//	return 0;
//}
// 
//  2.3.3
//int main()
//{
//	char a = 128;
//	printf("%u\n", a);
//	return 0;
//}
// 
//  2.3.4
//int main()
//{
//	int i = -20;
//	unsigned int j = 10;
//	printf("%d\n", i + j);
//	return 0;
//}
// 
//  2.3.5
//int main()
//{
//	unsigned int i = 0;
//	for (i = 9; i >= 0; i--)
//	{
//		printf("%u\n", i);
//		Sleep(1000);
//	}
//	return 0;
//}
//
//  2.3.6
//int main()
//{
//	char a[1000];
//	int i = 0;
//	for (i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;
//	}
//	printf("%d", strlen(a));
//	return 0;
//}
//
//  2.3.7
//unsigned char i = 0;
//// 取值范围的原因，死循环
//int main()
//{
//	for (i = 0; i <= 255; i++)
//	{
//		printf("hello world\n");
//	}
//	return 0;
//}
// 
//int my_strlen(const char* str)
//{
//	assert(str);
//	int count = 0;
//	while (*str)
//	{
//		str++;
//		count++;
//	}
//	return count;
//}
//int main()
//{
//	//int len = strlen("abcdef");
//	//printf("%d", len);
//	// 
//	//if (strlen("abc") - strlen("abcdef") >= 0)
//	//	printf(">");
//	//else
//	//	printf(">");
//	//
//	// 用 strlen 函数得出的是 >
//	// 因为 strlen 函数的返回值是 unsigned size_t
//	// 
//	if (my_strlen("abc") - my_strlen("abcdef") >= 0)
//		printf(">");
//	else
//		printf("<");
//
//	return 0;
//}
//
// 小结
// 大小端
// 
// 截断和整型提升
// 整形数据用 char 类型存储时会进行截断操作，截断的是原码的后 8位
// 用整数打印时又会进行整型提升操作，如果是有符号类型，高位补 1 ，无符号类型则高位补 0
// 整型提升后的打印需要注意是有符号打印 （%d） 还是无符号打印 （%u）
// 无符号打印则原码 = 补码，不需要转换，有符号打印需要将补码转换成原码再进行打印
//
//
// 3.浮点型数据在内存中的存储
//   常见浮点数
//   3.14
//   1E10
//   常见浮点类型
//   double  float long double 
//   浮点数范围
//   float.h 中定义
//
//  3.1例子
//   浮点型数据存储例子
//int main()
//{
//	int n = 9;
//	float* pFloat = (float*)&n;
//
//	printf("n=%d\n", n);
//	printf("pFloat=%f\n", *pFloat);  // 0
//
//	*pFloat = 9.0;
//
//	printf("num=%d\n", n);           // 9.0
//	printf("*pFloat=%f\n", *pFloat); // 1091567616
//	// 1001.0
//	// 1.001 * 2^3
//	// S=0;  M=1.001 ; E=3   E 还要加中间值 127
//	// 0        10000010        00100000000000000000000
//	// 符号位   指数位（+127）  有效数字（从小数位开始记，不够补 0）
//	// 01000001000100000000000000000000
//	// 1091567616
//	return 0; 
//}
// 
//  3.2 浮点数存储规则
// 
//  国际标准 IEEE 任何一个二进制浮点数 V 可以有以下表达方式
//  (-1)^S * M * 2^E
//  (-1)^S  表示符号位，S=0，表示正数，S=1，表示负数
//	M 表示有效数字， 大于等于 1，小于 2
//  2^E 表示指数位
// 
//  对于 32 位的浮点数，最高一位是符号位 S，接着的 8 位是指数 E，剩下的 23 位是有效数字 M
//  对于 64 位的浮点苏，最高一位是符号位 S，接着的 11 是指数 E， 剩下的 52 位是有效数字 M
// 
//  E 为一个无符号整数，如果 E 为 8 位，他的取值范围 0-255，
//  如果 E 为 11 位，他的取值范围 0-2047
//  由于科学计数法中有可能出现负数，所以规定，在存储 E 的真实值时必须再加上一个中间值
//  8 位的 E 中间值是 127， 11 位的 E 中间值是 1023
// 
//	在存储时，默认从小数点点后一位开始存储
// 
//  举例  float a = 0.5f   E = -1 + 127 = 126
//        double            
//   
// 
//  浮点数二进制
//	float = 5.0f -> 101.0 -> 1.01*2^2(因为是二进制，所以是2^2)
//  1.01^2^2 -> (-1)^S * 1.01 * 2^2  (S=0, M=1.01, E=2)
//  float = 9.5f -> 1001.1 -> 1.0011 * 2^3 
//  1.0011* 2^3 -> (-1)^S * 1.0011 * 2^3 
//
//
//int main()
//{
//	float f = 5.5;
//	// 5.5
//	// 101.1
//	// 1.011*2^2
//	// s=0 m=1.011 e=2
//	// 0
//	
//	return 0;
//}
// 指数 E 从内存中取出，可以分为三种情况
// E 不全为 0 ，或不全为 1
// E 的值减去 127 或 1023 得到真实值，再将有效数字 M 前加上第一位的 1
// 
// E 全为 0；
// 这时浮点数的指数 E ，即为真实值，有效数字 M 不再加上前面的 1，直接表示为 0.XXXXXXX
// 为了表示 +- 0，以及接近于 0 的很小的数字
// 
// E 全为 1
// 这时，如果有效数字 M 为全 0，表示无穷大的
//
// //
// 9 
// 00000000 00000000 00000000 00001001
// S=0；E=0;M=0000000 00000000 00001001
// 
//
// 
//
//
//
//